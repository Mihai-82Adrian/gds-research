<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>GDS Deep Dive</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">GDS Deep Dive</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-model-card" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Model Card</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-model-card">    
        <li>
    <a class="dropdown-item" href="./01_ModelCard_GDS_Details.html">
 <span class="dropdown-text">Details</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./01_ModelCard_P02_ExecutiveSummary.html">
 <span class="dropdown-text">Executive Summary</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./01_ModelCard_P03_Architecture.html">
 <span class="dropdown-text">Architecture</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./01_ModelCard_P04_LearningParadigm.html">
 <span class="dropdown-text">Learning Paradigm</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./01_ModelCard_P05_Data.html">
 <span class="dropdown-text">Data</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./01_ModelCard_P06_Explainability.html">
 <span class="dropdown-text">Explainability &amp; Interpretability</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-project-chronicle" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Project Chronicle</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-project-chronicle">    
        <li>
    <a class="dropdown-item" href="./02_Chronicle_GDS.html">
 <span class="dropdown-text">Concept</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./02_Chronicle_P02_Engineering.html">
 <span class="dropdown-text">Engineering</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./02_Chronicle_P03_Simulation.html">
 <span class="dropdown-text">Simulation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./02_Chronicle_P04_Evaluation.html">
 <span class="dropdown-text">Evaluation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./02_Chronicle_P05_Training_Journey_v2.html">
 <span class="dropdown-text">Training Journey</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-annexes" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Annexes</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-annexes">    
        <li>
    <a class="dropdown-item" href="./GDS_Concept/citations.html">
 <span class="dropdown-text">Sources &amp; Citations</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./GDS_Concept/overview.html">
 <span class="dropdown-text">ML Blueprint</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#model-details" id="toc-model-details" class="nav-link active" data-scroll-target="#model-details">Model Details</a>
  <ul class="collapse">
  <li><a href="#executive-summary-vision" id="toc-executive-summary-vision" class="nav-link" data-scroll-target="#executive-summary-vision">Executive Summary &amp; Vision</a></li>
  <li><a href="#detailed-architecture-how-the-system-reasons" id="toc-detailed-architecture-how-the-system-reasons" class="nav-link" data-scroll-target="#detailed-architecture-how-the-system-reasons">Detailed Architecture (How the System Reasons)</a>
  <ul class="collapse">
  <li><a href="#the-5-layers-of-gds" id="toc-the-5-layers-of-gds" class="nav-link" data-scroll-target="#the-5-layers-of-gds">The 5 Layers of GDS</a></li>
  <li><a href="#summary-of-a-thought" id="toc-summary-of-a-thought" class="nav-link" data-scroll-target="#summary-of-a-thought">Summary of a “Thought”</a></li>
  </ul></li>
  <li><a href="#learning-paradigm" id="toc-learning-paradigm" class="nav-link" data-scroll-target="#learning-paradigm">Learning Paradigm</a>
  <ul class="collapse">
  <li><a href="#core-principles" id="toc-core-principles" class="nav-link" data-scroll-target="#core-principles">Core Principles</a></li>
  <li><a href="#case-study-the-simulation" id="toc-case-study-the-simulation" class="nav-link" data-scroll-target="#case-study-the-simulation">Case Study: The Simulation</a></li>
  </ul></li>
  <li><a href="#data-lexicon-construction-csi-hdc" id="toc-data-lexicon-construction-csi-hdc" class="nav-link" data-scroll-target="#data-lexicon-construction-csi-hdc">Data &amp; Lexicon Construction (CSI-HDC)</a>
  <ul class="collapse">
  <li><a href="#primary-data-sources" id="toc-primary-data-sources" class="nav-link" data-scroll-target="#primary-data-sources">Primary Data Sources</a></li>
  <li><a href="#the-generation-pipeline-lexiconbuilder" id="toc-the-generation-pipeline-lexiconbuilder" class="nav-link" data-scroll-target="#the-generation-pipeline-lexiconbuilder">The Generation Pipeline (<code>LexiconBuilder</code>)</a></li>
  </ul></li>
  <li><a href="#evaluation-ethics-and-api" id="toc-evaluation-ethics-and-api" class="nav-link" data-scroll-target="#evaluation-ethics-and-api">Evaluation, Ethics, and API</a>
  <ul class="collapse">
  <li><a href="#evaluation" id="toc-evaluation" class="nav-link" data-scroll-target="#evaluation">Evaluation</a></li>
  <li><a href="#ethical-considerations-social-impact" id="toc-ethical-considerations-social-impact" class="nav-link" data-scroll-target="#ethical-considerations-social-impact">Ethical Considerations &amp; Social Impact</a></li>
  <li><a href="#model-api" id="toc-model-api" class="nav-link" data-scroll-target="#model-api">Model API</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<div id="tsparticles"></div>




<section id="model-details" class="level1">
<h1>Model Details</h1>
<ul>
<li><strong>Research Project</strong>: GDS (Geometrodynamic Semantics)</li>
<li><strong>Version</strong>: 1.1 (as of October 2025)</li>
<li><strong>Researcher</strong>: Mihai A. Mateescu</li>
<li><strong>Initiative</strong>: Independent Research &amp; Development Genesis</li>
<li><strong>Contact</strong>: <a href="mailto:mihai.mateescu@web.de">mihai.mateescu@web.de</a></li>
<li><strong>Core Languages</strong>: Rust, Julia</li>
<li><strong>Technology Stack</strong>:
<ul>
<li><strong>Core Logic &amp; Orchestration</strong>: Rust</li>
<li><strong>Numerical Backend (HDC)</strong>: Julia (via FFI)</li>
<li><strong>Storage Format</strong>: Apache Parquet (with ZSTD compression)</li>
<li><strong>Data Pipeline / In-Memory</strong>: Apache Arrow</li>
<li><strong>Checkpointing &amp; Dynamic Overlay</strong>: LMDB (via <code>heed</code>)</li>
<li><strong>k-NN Indexing (planned)</strong>: FAISS (Binary)</li>
</ul></li>
</ul>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
About This Research
</div>
</div>
<div class="callout-body-container callout-body">
<p>This document presents a research prototype exploring physics-inspired artificial intelligence. This work is conducted independently without institutional affiliation. For background and collaboration opportunities, see <a href="./00_About_Research.html">About the Researcher</a>.</p>
</div>
</div>
<section id="executive-summary-vision" class="level2">
<h2 class="anchored" data-anchor-id="executive-summary-vision">Executive Summary &amp; Vision</h2>
<p>GDS (Geometrodynamic Semantics) is a research prototype exploring an alternative to traditional, statistics-based Transformer architectures. Rather than predicting the next token, GDS models semantic reasoning as a physical phenomenon.</p>
<p>Inspired by Einstein’s theory of General Relativity, GDS treats concepts as “semantic particles” possessing intrinsic properties: <strong>mass</strong> (semantic importance), <strong>charge</strong> (the hyperdimensional vector), and <strong>spin</strong> (affective value). These particles are generated by the <strong>CSI-HDC</strong> (Conceptual State Injector using Hyperdimensional Computing)—a semantic tokenizer that replaces traditional token sequences with 20,000-dimensional binary hypervectors.</p>
<p>The CSI-HDC’s output is not a flat sequence of tokens, but a dynamic field of interacting particles. When processed by the GDS engine, this field warps a high-dimensional “conceptual space”. Reasoning is then modeled as finding the path of least resistance—a <strong>geodesic</strong>—through this curved semantic manifold.</p>
<p>Learning occurs not through backpropagation, but through a Hebbian-style mechanism that modifies the geometry of the space itself. A dynamic <strong>Overlay</strong> layer adds contextual adjustments to edge costs in the graph. Successful reasoning paths are reinforced, making them “cheaper” and more likely in future queries. This process is governed by internal evaluation and a <code>ValidationGate</code>, enabling autonomous learning based on coherence principles rather than direct supervision.</p>
<p>The result is a research prototype demonstrating efficient, scalable, and—most importantly—<strong>explainable</strong> semantic reasoning, where every path can be audited and understood step-by-step.</p>
</section>
<section id="detailed-architecture-how-the-system-reasons" class="level2">
<h2 class="anchored" data-anchor-id="detailed-architecture-how-the-system-reasons">Detailed Architecture (How the System Reasons)</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/kg_snapshot.jpeg" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>GDS Knowledge Graph Overview</figcaption>
</figure>
</div>
<p>The GDS cognitive architecture is a multi-layered research prototype where each layer has a distinct responsibility, from static data storage to dynamic, adaptive learning. The reasoning process emerges from the interaction of these layers.</p>
<section id="the-5-layers-of-gds" class="level3">
<h3 class="anchored" data-anchor-id="the-5-layers-of-gds">The 5 Layers of GDS</h3>
<ol type="1">
<li><strong>Semantic Base (The Static Universe)</strong>
<ul>
<li><strong>Component:</strong> A large-scale, compressed Parquet file containing the lexicon of all “semantic particles”.</li>
<li><strong>Role:</strong> This is the foundational, long-term memory of the system. It contains millions of concepts, each with its pre-calculated mass (<code>m0</code>), affective spin (VAD), and a unique 20,000-bit HDC vector (<code>q</code>).</li>
<li><strong>Includes:</strong> A static graph of <strong>structural edges</strong> derived from curated knowledge bases (e.g., ConceptNet’s <code>IsA</code> relation).</li>
</ul></li>
<li><strong>Proximity Graph (The Implicit Network)</strong>
<ul>
<li><strong>Component:</strong> A graph layer constructed on top of the Semantic Base. Its crucial feature is the inclusion of <strong>proximity edges</strong>.</li>
<li><strong>Role:</strong> These edges are not explicit in the source data. They are discovered by performing a k-Nearest Neighbors (k-NN) search (using FAISS) on the HDC vectors. This allows the model to create novel connections between semantically similar concepts, even if they were not explicitly linked in any knowledge base. This graph represents the fabric of the “conceptual space”.</li>
</ul></li>
<li><strong>Context Overlay (The Ephemeral Mind)</strong>
<ul>
<li><strong>Component:</strong> A dynamic key-value store (LMDB) that maps graph edges to a <code>delta</code> value.</li>
<li><strong>Role:</strong> This is the model’s short-term, contextual memory. It holds temporary adjustments to the “cost” of traversing an edge. When the model learns, it doesn’t modify the static graph; it simply adds a small positive (penalty) or negative (reinforcement) delta to this overlay. It is volatile and session-specific by default.</li>
</ul></li>
<li><strong>Geodesic Runtime (The “Thinker”)</strong>
<ul>
<li><strong>Component:</strong> The <code>Reasoner</code> module, which implements a graph-traversal algorithm (A*).</li>
<li><strong>Role:</strong> This is the active part of the model. When given a start and a goal concept, the <code>Reasoner</code> does not just find the shortest path; it finds the path of <strong>least cost</strong>. The cost function is a sophisticated, weighted sum that makes the process “geodesic”:
<ul>
<li><code>Cost(edge) = a�(1/m0) + ߷(?VAD) + ?�(1/rel_strength) + ?�(Overlay_Delta)</code></li>
</ul></li>
<li>This means the <code>Reasoner</code> naturally prefers paths that go through important concepts (high <code>m0</code>), avoid sharp emotional shifts (low <code>?VAD</code>), follow strong structural relations, and are influenced by recent learning (<code>Overlay_Delta</code>).</li>
</ul></li>
<li><strong>Learning Loop (The “Neuroplasticity”)</strong>
<ul>
<li><strong>Component:</strong> The <code>learn</code> and <code>gating</code> modules.</li>
<li><strong>Role:</strong> This layer implements the model’s ability to adapt. After a reasoning task, an internal or external evaluation can trigger a learning event. The <code>learn_edges</code> function applies Hebbian-style updates to the <code>Context Overlay</code>. A <code>ValidationGate</code> then determines if these temporary changes have improved the model’s overall performance on a set of evaluation tasks before they are consolidated into a more permanent, versioned overlay.</li>
</ul></li>
</ol>
</section>
<section id="summary-of-a-thought" class="level3">
<h3 class="anchored" data-anchor-id="summary-of-a-thought">Summary of a “Thought”</h3>
<p>A GDS “thought” process can be summarized as:</p>
<ol type="1">
<li>A query initiates a search for a low-cost path between two concepts in the <strong>Proximity Graph</strong>.</li>
<li>The <strong><code>Reasoner</code></strong> explores the graph, calculating the cost of each potential step using the multi-faceted cost function, which reads from both the static <strong>Semantic Base</strong> and the dynamic <strong>Context Overlay</strong>.</li>
<li>The resulting lowest-cost path is returned as the “thought” or solution.</li>
<li>Based on the outcome, the <strong>Learning Loop</strong> can be triggered to update the <strong>Context Overlay</strong>, reinforcing or penalizing edges, thus altering the geometry of the space for the next, similar thought.</li>
</ol>
</section>
</section>
<section id="learning-paradigm" class="level2">
<h2 class="anchored" data-anchor-id="learning-paradigm">Learning Paradigm</h2>
<p>The GDS learning paradigm is fundamentally different from the backpropagation and gradient descent methods that power traditional Large Language Models. It is a form of <strong>autonomous, Hebbian-style learning</strong> that modifies the geometry of the conceptual space in response to experience.</p>
<section id="core-principles" class="level3">
<h3 class="anchored" data-anchor-id="core-principles">Core Principles</h3>
<ol type="1">
<li><strong>No Backpropagation:</strong> The model does not compute gradients across a massive neural network. Learning is a local, lightweight process.</li>
<li><strong>Learning by Modifying Costs:</strong> Instead of adjusting neuron weights, GDS learns by adjusting the “cost” of traversing specific edges in the semantic graph. This is done by writing small delta values to the dynamic <code>Context Overlay</code>.</li>
<li><strong>Reinforcement and Penalization:</strong> Paths that lead to successful or “coherent” outcomes are <strong>reinforced</strong> (their edges receive a negative delta, making them cheaper and more attractive to the <code>Reasoner</code>). Paths that are evaluated as poor alternatives are <strong>penalized</strong> (their edges receive a positive delta, making them more expensive).</li>
<li><strong>Internal Evaluation:</strong> The model does not strictly require external, supervised labels to learn. As demonstrated in our simulation, it can employ internal heuristics (such as a “coherence score” based on concept mass) to decide which paths are “better” and thus worthy of reinforcement.</li>
<li><strong>Stability and Explainability:</strong> Because learning only affects the overlay, the foundational knowledge graph remains stable. The changes are auditable (one can inspect the deltas in the overlay) and their effect is directly observable in the <code>Reasoner</code>’s behavior and cost calculations.</li>
</ol>
</section>
<section id="case-study-the-simulation" class="level3">
<h3 class="anchored" data-anchor-id="case-study-the-simulation">Case Study: The Simulation</h3>
<p>Our simulation provided a perfect, concrete example of this paradigm in action:</p>
<ol type="1">
<li><strong>Initial State:</strong> The <code>Reasoner</code> initially chose the cheapest, most obvious path: <code>king -&gt; power</code>.</li>
<li><strong>Internal Evaluation:</strong> An internal metric, the “coherence score” (sum of concept masses), evaluated the alternative path <code>king -&gt; crown -&gt; power</code> as being semantically richer, despite its higher initial cost.</li>
<li><strong>Autonomous Learning:</strong> This internal evaluation triggered a learning event. The <code>learn_edges</code> function was called to apply a strong negative delta (reinforcement) to the <code>king -&gt; crown</code> and <code>crown -&gt; power</code> edges, and a positive delta (penalty) to the <code>king -&gt; power</code> edge.</li>
<li><strong>Behavioral Change:</strong> When the query was run again, the <code>Reasoner</code>, factoring in the new deltas from the <code>Overlay</code>, found that the path through <code>crown</code> was now the new cheapest path.</li>
</ol>
<p>This demonstrates a complete, autonomous cycle: <strong>Reason → Evaluate → Self-Reinforce → Reason Differently</strong>. The system adapts its reasoning based on internal evaluation principles, a process resembling neuroplasticity more than traditional supervised learning.</p>
</section>
</section>
<section id="data-lexicon-construction-csi-hdc" class="level2">
<h2 class="anchored" data-anchor-id="data-lexicon-construction-csi-hdc">Data &amp; Lexicon Construction (CSI-HDC)</h2>
<p>The foundation of the GDS system is the <strong>Semantic Base</strong>, a large-scale lexicon of “semantic particles” generated by the <strong>CSI-HDC</strong> (Conceptual State Injector using Hyperdimensional Computing) pipeline. This pipeline processes and synthesizes information from multiple data sources to generate concept representations with physics-inspired properties.</p>
<section id="primary-data-sources" class="level3">
<h3 class="anchored" data-anchor-id="primary-data-sources">Primary Data Sources</h3>
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Data Source</th>
<th style="text-align: left;">Location in Project</th>
<th style="text-align: left;">Role &amp; Contribution</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>ConceptNet</strong></td>
<td style="text-align: left;"><code>data/raw/assertions.csv</code></td>
<td style="text-align: left;">Provides the primary <strong>structural graph</strong> of common-sense relationships (e.g., <code>UsedFor</code>, <code>CapableOf</code>, <code>PartOf</code>). It forms the backbone of explicit knowledge.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Numberbatch</strong></td>
<td style="text-align: left;"><code>data/raw/numberbatch.txt</code></td>
<td style="text-align: left;">A set of pre-trained 300-dimensional word embeddings. It is the primary source for generating the 20,000-dimensional HDC vectors and serves as a fallback for calculating affective scores.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>NRC-VAD Lexicon</strong></td>
<td style="text-align: left;"><code>data/raw/nrc_vad/</code></td>
<td style="text-align: left;">Provides affective scores for English words across three dimensions: <strong>V</strong>alence (pleasure/displeasure), <strong>A</strong>rousal (intensity), and <strong>D</strong>ominance (control). This is the source for the <code>spin</code> property of English particles.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>German Norms</strong></td>
<td style="text-align: left;"><code>data/raw/german_norms/</code></td>
<td style="text-align: left;">The German equivalent of the NRC-VAD lexicon, providing affective scores for German words.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>OEWM Lexicons</strong></td>
<td style="text-align: left;"><code>data/oewm_lexicons/</code></td>
<td style="text-align: left;">Open English, German, and Romanian WordNet data. This is a crucial source for <strong>normalization, synonymy (aliases), and word frequency priors</strong>. It significantly boosts the quality of mass calculation and the coverage of other lookups.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>BabelNet Cache</strong></td>
<td style="text-align: left;"><code>data/enrichment/babelnet_cache.db</code></td>
<td style="text-align: left;">A local SQLite database that caches results from the BabelNet API. This is used in a daily enrichment loop to add new, high-quality multilingual relations to the graph, expanding its knowledge base over time.</td>
</tr>
</tbody>
</table>
</section>
<section id="the-generation-pipeline-lexiconbuilder" class="level3">
<h3 class="anchored" data-anchor-id="the-generation-pipeline-lexiconbuilder">The Generation Pipeline (<code>LexiconBuilder</code>)</h3>
<p>The process is orchestrated by the <code>LexiconBuilder</code> in the Rust codebase and follows several key stages:</p>
<ol type="1">
<li><strong>Aggregation:</strong> Raw assertions from ConceptNet are streamed and aggregated into a per-concept map, building a preliminary list of relations.</li>
<li><strong>Normalization &amp; Enrichment:</strong> Lemmas are normalized using OEWM. This step also discovers aliases (synonyms) that will be used in later stages.</li>
<li><strong>Quality Scoring:</strong> Each potential concept is scored based on a set of heuristics: its connectivity in the graph, whether it has a Numberbatch embedding, and its coverage in affective lexicons.</li>
<li><strong>Filtering:</strong> Concepts that do not meet a minimum quality threshold (e.g., <code>min_relations</code>) are discarded.</li>
<li><strong>Property Calculation:</strong> For each high-quality concept:
<ul>
<li><strong>Mass (<code>m0</code>)</strong> is calculated based on its graph connectivity, boosted by its frequency from OEWM.</li>
<li><strong>Spin (<code>s</code>)</strong> is calculated from the affective lexicons (NRC-VAD, German Norms).</li>
<li><strong>Charge (<code>q</code>)</strong> is generated by passing its 300D Numberbatch embedding to the Julia HDC server, which expands it into a 20,000-bit binary hypervector.</li>
</ul></li>
<li><strong>Export:</strong> The final collection of <code>SemanticParticle</code> objects is written to a compressed Parquet file, which becomes the <strong>Semantic Base</strong> for the GDS runtime.</li>
</ol>
</section>
</section>
<section id="evaluation-ethics-and-api" class="level2">
<h2 class="anchored" data-anchor-id="evaluation-ethics-and-api">Evaluation, Ethics, and API</h2>
<section id="evaluation" class="level3">
<h3 class="anchored" data-anchor-id="evaluation">Evaluation</h3>
<p>Evaluation of the GDS model is two-fold, targeting both the quantitative performance of the system and the qualitative relevance of its reasoning.</p>
<ol type="1">
<li><strong>System Performance:</strong> As detailed in the <code>OPTIMIZATION_ROADMAP.md</code>, the lexicon construction pipeline is evaluated on metrics such as storage efficiency (bytes/particle), compression ratio, and throughput (particles/sec). The live system is evaluated on query latency and memory footprint.</li>
<li><strong>Semantic Quality:</strong> The quality of the model’s reasoning is evaluated through controlled tests. The simulation we performed is a prime example of a qualitative evaluation, designed to verify that the model’s behavior aligns with its core theoretical principles. Formal evaluation suites are planned to measure performance on tasks like:
<ul>
<li><strong>Cross-lingual Retrieval:</strong> Testing if <code>dog</code> (en) is correctly identified as being close to <code>Hund</code> (de).</li>
<li><strong>Guided Analogy:</strong> Testing the quality of typed compositions (e.g., <code>king - man + woman = queen</code>).</li>
<li><strong>Path Coherence:</strong> Measuring the semantic consistency of paths found by the <code>Reasoner</code>.</li>
</ul></li>
</ol>
</section>
<section id="ethical-considerations-social-impact" class="level3">
<h3 class="anchored" data-anchor-id="ethical-considerations-social-impact">Ethical Considerations &amp; Social Impact</h3>
<ul>
<li><strong>Transparency &amp; Explainability:</strong> A core design goal of GDS is to be explainable. Unlike the opaque nature of large transformer models, every step of a GDS “thought” process can be audited. The <code>PathExplain</code> object provides a full trace of the chosen path, the costs of each edge, and the contribution of each component (mass, VAD, overlay), making the model’s decisions transparent.</li>
<li><strong>Bias Mitigation:</strong> The model’s knowledge is derived from its source data. While this data can contain biases, the GDS architecture offers several points of intervention. Telemetry tracks distributions per language and domain, allowing for monitoring of imbalances. The <code>Overlay</code> can also be used to apply targeted, corrective penalties to biased or undesirable associations in the graph.</li>
<li><strong>Control:</strong> The learning mechanism includes a <code>ValidationGate</code>, ensuring that autonomous changes to the <code>Overlay</code> are only consolidated after verifying that they do not degrade overall performance on a set of control tasks. This provides a crucial layer of human oversight and control over the model’s evolution.</li>
</ul>
</section>
<section id="model-api" class="level3">
<h3 class="anchored" data-anchor-id="model-api">Model API</h3>
<p>The GDS runtime exposes a clear, function-oriented API for interaction. The primary methods are:</p>
<ul>
<li><code>search_semantic(query, k)</code>: Performs a k-NN search in the HDC space to find the <code>k</code> concepts most similar to a query.</li>
<li><code>compose(vector_a, vector_b, operation)</code>: Creates a new concept by composing two existing vectors using typed HDC operations.</li>
<li><code>reason(start_concept, goal_concept, constraints)</code>: The core function. It invokes the <code>Reasoner</code> to find the lowest-cost path between two concepts, returning the full <code>PathExplain</code> object.</li>
<li><code>learn(path, negatives)</code>: Triggers a learning event. It takes a path to be reinforced and a set of negative edges to be penalized, which then updates the <code>Context Overlay</code>.</li>
</ul>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script src="https://cdn.jsdelivr.net/npm/tsparticles@2/tsparticles.bundle.min.js"></script>
<script src="./gds_particles.js"></script>"




</body></html>